/*! \page gds_internal_documentation GDS Developers Documentation

\section gds_intro_sec Introduction
The Gemini Data Service (GDS) is the system that will (partially) replace the Gemini Data Handling System (DHS) for GIAPI
based instruments, such as GPI.

\section gds_bundles_sec Bundles
The GDS is comprised of the following bundles:
- \subpage gds-actors-composer
- \subpage gds-epics-actors
- \subpage gds-odb-actors
- \subpage gds-instrument-status-actors

\section design_sec Design Issues

\subsection composition_sec Data Values Composition
The GDS is a component that listen for Observation Events sent from an instrument and that reacts to them
by sampling the state of the Observatory. observation database, instrument, etc. The sampled information is then added
to the data files produced by the instrument. This process is called value composition, where all sampled values upon
observation events are composed into the data file.

The design uses the concept of actors or agents that are independent objects that can sample the information. This design
makes it simple to keep track of the progress and make each of these actors, a single purpose, very simple to implement
component.

It also makes it easy to extend the composition as the core components can discover new modules in charge of gathering
these values

\subsection datalabel_sec Data Label Generation
Currently, the dataset names (or datalabels) generation is performed via a control command by the DHS, at the request of
the seqexec. The seqexec later specifies who will contribute data to this dataset, at which point itself and the
contributors can start sending data.
A first study of the following documents and code was done:
- ICD 3: Bulk Data Transfer
- ICD 1.9/3.2: Science Instrument to Data Handling System
- dhs/dhs/dhsData/list.C
- dhs/dhs/dhsData/ctl.C

This investigation shows that the datalabel generation functionality is fairly independent from the data storing
functionality, in a way that no files are created, and no internal state changes (except for a list of the last labels
generated), when labels are generated. Furthermore, data can be sent with arbitrary datalabels not generated by the DHS.

So, there are three main alternatives for instruments using the GDS:
- Continue with the seqexec request datalabels to the DHS, and then not sending any data to the DHS, but to the GDS. The
major disadvantage is a dependance on the DHS for GIAPI based instruments.
- Extract the datalabel generation from the DHS to an external service that the DHS can query for most instruments, and
the seqexec can query for GIAPI based instruments. The major disadvantage is the risk of modifying a complex piece of
software like the DHS. For consistency and simplicity, if this option is taken, the communication with the new external
service should use the same protocol as the one used in \ref fits_seqexec_sec.
- Generate datalabels independently in GDS and DHS, and ensure no collisions will happen by changing the naming convention.


\subsection fits_seqexec_sec Sending FITS Headers from Seqexec to GDS
The FITS headers that the seqexec provides, must be passed to the GDS. There aren't many suitable remote communication
alternatives supported by tcl and java/scala. The most suitable seems to be XMLRPC, which has implementations in both
languages, and is relatively simple, but much higher level than using plain http or tcp.

\section gds_performance GDS Preliminary Performance Test

- Average timing for event OBS_PREP: 38[ms]
- Average timing for event OBS_START_ACQ: 18[ms]
- Average timing for event OBS_END_ACQ: 20[ms]
- Average timing for event OBS_END_DSET_WRITE: 23[ms]


\section random_sec Random Rambling
Just some notes:
- The "current" DHS is not tags/current, but the trunk.
- Can't get a tcl script to communicate with my local DHS. Seems to be a problem with my IMP service.
- A C++ client does work.
- Can generate datalabels.
- If data arrives with a label that already exists, a dash and a correlative number is appended to the name.

\subsection gds_performance_testing GDS Performance Tests
Testing was done to check the performance of GDS when confronted to many simultaneous keywords. To do
so a special testing program and configuration was created

- A test program was created in giapi-glue-cc that can post a large amount of status updates and seqexec keywords
- A configuration matching the test program war written in gmp-server/src/main/etc/conf/gds-keywords-highcount.conf
and it needs to be referred from GDSConfigurationServiceImpl-default.cfg

The main objective is to determine the bounds of how fast GDS can process a file comparable to those required for GPI
As a reference, we'd ideally be able to have expositions of one second and process the file in a compalable time

The tests were carried out on 7/20/2011 on an iMac with all the components on the local machine

Some results:
1 Constructing actors takes an appreciable time, for example constructing 80 SEQEXEC actors takes 30-40 [ms]
Construction of 508 STATUS actors takes 122 [ms] 
2 Collection of SEQEXEC items takes ar appreciable time, e.g.:
    FitsKeyword{name='OBSTYPE'} -> 12[ms]
    FitsKeyword{name='SSA'} -> 14[ms]
    FitsKeyword{name='OBSCLASS'} -> 14[ms]
    FitsKeyword{name='OBSID'} -> 15[ms]
    FitsKeyword{name='RAWCC'} -> 12[ms]
This in an in memory call so, the slowness is probably due to the actor based design of TemporarySeqexecKeywordsDatabase
3 The waiting part of KeywordSetComposer in the method waitForDataAndReply is suboptimal, e.g for SEQEXEC actor it produces:
    Waiting for data took 109 [ms] 
4 Requesting STATUS items is very fast, for example taking 160-180 [ms] to read 508 status items, this is probably coming mostly from the
issue in 3

Some recommendations by issue number:
1.1 Use a single actor per set of keywords, for example only one Seqexec actor for the 80 requested keywords
1.2 Reuse actor instances. This would complicate the design though since it would require keeping state
2.1 Change TemporarySeqexecKeywordsDatabase to allow retrieval of multiple keywords at once, in combination with 1.2
2.2 Add a method to make a copy of TemporarySeqexecKeywordsDatabase and operate on that, thus avoiding the issues related to
the actor-based calls
3.1 Redesign 3 so that waiting for data collection takes app the same as the slowest actor

\subsection gds_memory_leaks_testing_sec GDS Memory Leaks Testing
Testing for memory leaks are possible by using the acqloop.sh script at the src/examples dir in giapi-glue, and then
checking the GDS using visualvm or jconsole

\li Start the GMP-GDS as indicated in the \ref user_manual.
\li Start the sequence command example in <tt> giapi-glue-cc/src/examples/ </tt> with: <tt>$ ./acqloop.sh </tt>. You may want to edit the script to change the amount of iterations
\li Start jconsole (Installed as part of the JDK) and make it connect to the org.apache.felix.main.Main process
\li The script should run for quite a while sending observation commands in sequence to the GDS and then to the simulated instrument
\li The output of the script would look like:
\verbatim
Starting Observation Process Example
> POST / HTTP/1.1
Host: localhost:12345
Accept: */*
Content-Type: text/xml
Content-Length: 507

< HTTP/1.1 200 OK
< Server: Apache XML-RPC 1.0
< Connection: close
< Content-Type: text/xml
< Content-Length: 199
< 
* we are done reading and this is set to close, stop send
* Closing connection #0
* About to connect() to localhost port 12345 (#0)
*   Trying 127.0.0.1... * connected
* Connected to localhost (127.0.0.1) port 12345 (#0)
> POST / HTTP/1.1
Host: localhost:12345
Accept: */*
Content-Type: text/xml
Content-Length: 437

< HTTP/1.1 200 OK
< Server: Apache XML-RPC 1.0
< Connection: close
< Content-Type: text/xml
< Content-Length: 199
< 
* we are done reading and this is set to close, stop send
* Closing connection #0
<?xml version="1.0" encoding="UTF-8"?><methodResponse xmlns:ex="http://ws.apache.org/xmlrpc/namespaces/extensions"><params><param><value><boolean>1</boolean></value></param></params></methodResponse><?xml version="1.0" encoding="UTF-8"?><methodResponse xmlns:ex="http://ws.apache.org/xmlrpc/namespaces/extensions"><params><param><value><boolean>1</boolean></value></param></params></methodResponse>Retrieving Data file location
2011-07-06 22:04:19,752 [0x7fff7109fcc0] INFO  giapi.ServicesUtilImpl - Property requested for key: DHS_SCIENCE_DATA_PATH
DataSciencePath : /tmp
TempFile : /tmp/S20110427-01.fits
POST 0
2011-07-06 22:04:19,771 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_PREP datalabel: S20110427-01
POST 1
2011-07-06 22:04:20,771 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_ACQ datalabel: S20110427-01
POST 2
2011-07-06 22:04:22,772 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_ACQ datalabel: S20110427-01
POST 3
2011-07-06 22:04:24,773 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_READOUT datalabel: S20110427-01
POST 4
2011-07-06 22:04:25,773 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_READOUT datalabel: S20110427-01
POST 5
2011-07-06 22:04:26,774 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_DSET_WRITE datalabel: S20110427-01
POST 6
2011-07-06 22:04:27,775 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_DSET_WRITE datalabel: S20110427-01

\endverbatim

\li On jconsole the memory consumption can be checked on the Memory tab as shown below:
\image html jconsole_memory_tab.png


*/
