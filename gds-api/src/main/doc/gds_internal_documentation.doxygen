/*! \page gds_internal_documentation GDS Developers Documentation

\section gds_intro_sec Introduction
The Gemini Data Service (GDS) is the system that will (partially) replace the Gemini Data Handling System (DHS) for GIAPI
based instruments, such as GPI.

\section gds_bundles_sec Bundles
The GDS is comprised of the following bundles:
- \subpage gds-actors-composer
- \subpage gds-epics-actors
- \subpage gds-odb-actors
- \subpage gds-instrument-status-actors

\section design_sec Design Issues

\subsection composition_sec Data Values Composition
The GDS is a component that listen for Observation Events sent from an instrument and that reacts to them
by sampling the state of the Observatory. observation database, instrument, etc. The sampled information is then added
to the data files produced by the instrument. This process is called value composition, where all sampled values upon
observation events are composed into the data file.

The design uses the concept of actors or agents that are independent objects that can sample the information. This design
makes it simple to keep track of the progress and make each of these actors, a single purpose, very simple to implement
component.

It also makes it easy to extend the composition as the core components can discover new modules in charge of gathering
these values

\subsection datalabel_sec Data Label Generation
Currently, the dataset names (or datalabels) generation is performed via a control command by the DHS, at the request of
the seqexec. The seqexec later specifies who will contribute data to this dataset, at which point itself and the
contributors can start sending data.
A first study of the following documents and code was done:
- ICD 3: Bulk Data Transfer
- ICD 1.9/3.2: Science Instrument to Data Handling System
- dhs/dhs/dhsData/list.C
- dhs/dhs/dhsData/ctl.C

This investigation shows that the datalabel generation functionality is fairly independent from the data storing
functionality, in a way that no files are created, and no internal state changes (except for a list of the last labels
generated), when labels are generated. Furthermore, data can be sent with arbitrary datalabels not generated by the DHS.

So, there are three main alternatives for instruments using the GDS:
- Continue with the seqexec request datalabels to the DHS, and then not sending any data to the DHS, but to the GDS. The
major disadvantage is a dependance on the DHS for GIAPI based instruments.
- Extract the datalabel generation from the DHS to an external service that the DHS can query for most instruments, and
the seqexec can query for GIAPI based instruments. The major disadvantage is the risk of modifying a complex piece of
software like the DHS. For consistency and simplicity, if this option is taken, the communication with the new external
service should use the same protocol as the one used in \ref fits_seqexec_sec.
- Generate datalabels independently in GDS and DHS, and ensure no collisions will happen by changing the naming convention.


\subsection fits_seqexec_sec Sending FITS Headers from Seqexec to GDS
The FITS headers that the seqexec provides, must be passed to the GDS. There aren't many suitable remote communication
alternatives supported by tcl and java/scala. The most suitable seems to be XMLRPC, which has implementations in both
languages, and is relatively simple, but much higher level than using plain http or tcp.

\section gds_performance GDS Preliminary Performance Test

- Average timing for event OBS_PREP: 38[ms]
- Average timing for event OBS_START_ACQ: 18[ms]
- Average timing for event OBS_END_ACQ: 20[ms]
- Average timing for event OBS_END_DSET_WRITE: 23[ms]


\section random_sec Random Rambling
Just some notes:
- The "current" DHS is not tags/current, but the trunk.
- Can't get a tcl script to communicate with my local DHS. Seems to be a problem with my IMP service.
- A C++ client does work.
- Can generate datalabels.
- If data arrives with a label that already exists, a dash and a correlative number is appended to the name.

*/
