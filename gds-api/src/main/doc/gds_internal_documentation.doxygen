/*! \page gds_internal_documentation GDS Developers Documentation

\section gds_intro_sec Introduction
The Gemini Data Service (GDS) is the system that will (partially) replace the Gemini Data Handling System (DHS) for GIAPI
based instruments, such as GPI.

\section gds_bundles_sec Bundles
The GDS is comprised of the following bundles:
- \subpage gds-actors-composer
- \subpage gds-epics-actors
- \subpage gds-odb-actors
- \subpage gds-instrument-status-actors

\section design_sec Design Issues

\subsection composition_sec Data Values Composition
The GDS is a component that listen for Observation Events sent from an instrument and that reacts to them
by sampling the state of the Observatory. observation database, instrument, etc. The sampled information is then added
to the data files produced by the instrument. This process is called value composition, where all sampled values upon
observation events are composed into the data file.

The design uses the concept of actors or agents that are independent objects that can sample the information. This design
makes it simple to keep track of the progress and make each of these actors, a single purpose, very simple to implement
component.

It also makes it easy to extend the composition as the core components can discover new modules in charge of gathering
these values

\subsection datalabel_sec Data Label Generation
Currently, the dataset names (or datalabels) generation is performed via a control command by the DHS, at the request of
the seqexec. The seqexec later specifies who will contribute data to this dataset, at which point itself and the
contributors can start sending data.
A first study of the following documents and code was done:
- ICD 3: Bulk Data Transfer
- ICD 1.9/3.2: Science Instrument to Data Handling System
- dhs/dhs/dhsData/list.C
- dhs/dhs/dhsData/ctl.C

This investigation shows that the datalabel generation functionality is fairly independent from the data storing
functionality, in a way that no files are created, and no internal state changes (except for a list of the last labels
generated), when labels are generated. Furthermore, data can be sent with arbitrary datalabels not generated by the DHS.

So, there are three main alternatives for instruments using the GDS:
- Continue with the seqexec request datalabels to the DHS, and then not sending any data to the DHS, but to the GDS. The
major disadvantage is a dependance on the DHS for GIAPI based instruments.
- Extract the datalabel generation from the DHS to an external service that the DHS can query for most instruments, and
the seqexec can query for GIAPI based instruments. The major disadvantage is the risk of modifying a complex piece of
software like the DHS. For consistency and simplicity, if this option is taken, the communication with the new external
service should use the same protocol as the one used in \ref fits_seqexec_sec.
- Generate datalabels independently in GDS and DHS, and ensure no collisions will happen by changing the naming convention.


\subsection fits_seqexec_sec Sending FITS Headers from Seqexec to GDS
The FITS headers that the seqexec provides, must be passed to the GDS. There aren't many suitable remote communication
alternatives supported by tcl and java/scala. The most suitable seems to be XMLRPC, which has implementations in both
languages, and is relatively simple, but much higher level than using plain http or tcp.

\section gds_performance GDS Preliminary Performance Test

- Average timing for event OBS_PREP: 38[ms]
- Average timing for event OBS_START_ACQ: 18[ms]
- Average timing for event OBS_END_ACQ: 20[ms]
- Average timing for event OBS_END_DSET_WRITE: 23[ms]


\section random_sec Random Rambling
Just some notes:
- The "current" DHS is not tags/current, but the trunk.
- Can't get a tcl script to communicate with my local DHS. Seems to be a problem with my IMP service.
- A C++ client does work.
- Can generate datalabels.
- If data arrives with a label that already exists, a dash and a correlative number is appended to the name.

\subsection gds_memory_leaks_testing_sec GDS Memory Leaks Testing
Testing for memory leaks are possible by using the acqloop.sh script at the src/examples dir in giapi-glue, and then
checking the GDS using visualvm or jconsole

\li Start the GMP-GDS as indicated in the \ref user_manual.
\li Start the sequence command example in <tt> giapi-glue-cc/src/examples/ </tt> with: <tt>$ ./acqloop.sh </tt>. You may want to edit the script to change the amount of iterations
\li Start jconsole (Installed as part of the JDK) and make it connect to the org.apache.felix.main.Main process
\li The script should run for quite a while sending observation commands in sequence to the GDS and then to the simulated instrument
\li The output of the script would look like:
\verbatim
Starting Observation Process Example
* About to connect() to localhost port 12345 (#0)
*   Trying 127.0.0.1... * connected
* Connected to localhost (127.0.0.1) port 12345 (#0)
> POST / HTTP/1.1
Host: localhost:12345
Accept: */*
Content-Type: text/xml
Content-Length: 507

< HTTP/1.1 200 OK
< Server: Apache XML-RPC 1.0
< Connection: close
< Content-Type: text/xml
< Content-Length: 199
< 
* we are done reading and this is set to close, stop send
* Closing connection #0
* About to connect() to localhost port 12345 (#0)
*   Trying 127.0.0.1... * connected
* Connected to localhost (127.0.0.1) port 12345 (#0)
> POST / HTTP/1.1
Host: localhost:12345
Accept: */*
Content-Type: text/xml
Content-Length: 437

< HTTP/1.1 200 OK
< Server: Apache XML-RPC 1.0
< Connection: close
< Content-Type: text/xml
< Content-Length: 199
< 
* we are done reading and this is set to close, stop send
* Closing connection #0
<?xml version="1.0" encoding="UTF-8"?><methodResponse xmlns:ex="http://ws.apache.org/xmlrpc/namespaces/extensions"><params><param><value><boolean>1</boolean></value></param></params></methodResponse><?xml version="1.0" encoding="UTF-8"?><methodResponse xmlns:ex="http://ws.apache.org/xmlrpc/namespaces/extensions"><params><param><value><boolean>1</boolean></value></param></params></methodResponse>Retrieving Data file location
2011-07-06 22:04:19,752 [0x7fff7109fcc0] INFO  giapi.ServicesUtilImpl - Property requested for key: DHS_SCIENCE_DATA_PATH
DataSciencePath : /tmp
TempFile : /tmp/S20110427-01.fits
POST 0
2011-07-06 22:04:19,771 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_PREP datalabel: S20110427-01
POST 1
2011-07-06 22:04:20,771 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_ACQ datalabel: S20110427-01
POST 2
2011-07-06 22:04:22,772 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_ACQ datalabel: S20110427-01
POST 3
2011-07-06 22:04:24,773 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_READOUT datalabel: S20110427-01
POST 4
2011-07-06 22:04:25,773 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_READOUT datalabel: S20110427-01
POST 5
2011-07-06 22:04:26,774 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_DSET_WRITE datalabel: S20110427-01
POST 6
2011-07-06 22:04:27,775 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_DSET_WRITE datalabel: S20110427-01

\endverbatim
\li On jconsole the memory consumption can be checked on the Memory tab as shown below:
\image html jconsole_memory_tab.png

\attention As of 07/07/2011 there are at least two memory leaks identified 

*/
